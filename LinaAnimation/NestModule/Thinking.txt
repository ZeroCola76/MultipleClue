
//2024. 01. 24. DJ

ECS와 Object 대한 생각을 정리한다.-----------------------------------------------------------

Entity와 그 안에 담기는 Component들을 Object라고 생각을 하자.

그리고 그 Object가 실제 메모리 상에 존재하기 시작하는 순간 instance가 된다고 생각해보자.

그러면 하나의 씬을 이루는데 있어서 필요한 것은..

Object(Entity + Component)<정의>, Instance<존재하는 실체>, System<실체들의 규칙>

이렇게 세가지 이다. (물론 세밀하게 생각하면 더 있겠지만.. 일단 3개만 생각해보자.)

그럼 이때 각 3개들의 관리는 어디서 이루어져야 마땅할까.

일단 ObjectManager가 있어야하는 이유는 뭘까. 오브젝트의 생성과 삭제를 관리? 그렇다면
오브젝트 매니저는 Entity와 Component까지 까지 관리를 해야하는걸까..? 아니지 말도 안되는 소리다. 

하나의 매니저는 하나에 특화 되어 있어야한다. 
잡다한것이 붙으면 나중에 재활용하는데 있어서 장애가 될수 있다.

그럼 오브젝트 매니저는 오브젝트를 관리한다고 하기보다 instance를 관리하는 것이 맞겠다.
이미 구성이 된 Object들을 관리한다... 음..

그럼 EC는 어디서 관리할까 팩토리와 빌더를 통한다고 생각하자

씬매니저는 후에 만드는걸로 하고

지금 해야할것은 엔티티와 컴포넌트들의 정립인거같다.

빌더와 팩토리는 전에 만들어 두었던 구조를 참고하자. 

그럼 엔티티에 대한 생각을 정리한다.----------------------------------------------------------

엔티티는 여태까지 그릇이라고 생각했다.

그렇다면 모든 엔티티가 기본적으로 가지는 것들을 멤버로 박아두고 
컴포넌트들을 잡고있을 자료구조만을 만들어 주면 된다.

보통 벡터를 생각하겠지만.. 벡터를 씀에 있어 단점이 있을까?

unordered_map은 검색에 특화 되어있고 vector은 순회에 특화되어있다. 
하지만 후에 system을 짤때, 오브젝트의 속성을 검색함에 있어서는 unordered_map이 좀더 유용할것 같다.
어자피 내 생각에 컴포넌트 순회는 잘 안할것 같거든. 그리고 씬마다 몇천~몇만개의 오브젝트가 존재할거 같지는 않다. 
그럼 메모리 오버헤드를 감수할 근거가 된다. 후에 프로파일링을 통해 한번 비교해보는것도 좋을것 같다.

그럼 모든 엔티티에 꼭 필요한게 뭐가있을까? 모든 엔티티에 필요하다면 궅이 컴포넌트로 뺴지않아도 되지않을까.
멤버변수로는 이름.
멤버 함수로는 Initialize, Finalize정도가 있겠다.
그리고 std::unordered_map<std::wstring, std::shared_ptr<Component>>; 정도가 있겠다.

//-------------------------------------------------------------------------------------------
24. 01. 25 DJ

기석이와 이야기를 해보았고 툴에서 component를 추가 시 Entity에 적용이 되도록 바꿀수 있을까..?

기석이는 string값이 있었으면 좋다고 이야기를 했다. 

string값을 툴에서 입력을 하면 json파일에 저장을 했다가 후에 게임엔진에서... 일단 그전에...

jSon은 TRS와 키값을 줄수 있다고 한다. 

 json의 구조에 대해 일단 알아보자.

 https://namu.wiki/w/JSON

 json에서 표현 가능한 자료형은 문자열, 숫자, 불리언, 널, 객체..?!, 배열 6개이다..음.. 괜찬은데?

 JSON의 예시코드를 하나 보자.

 {
  "Entity": {
    "id": "player1",    "components": {
      "position": {"x": 10, "y": 20, "z": 30},
      "velocity": {"x": 5, "y": 0, "z": 0}
    }
  }
}

위는 JSON으로 간단한 ECS구조를 채용해본것이다. 

놀랍게도 Position값과 무려 Velocity값까지 뽑아낼수 있다니...! 감격스럽다. 

이러면 Entity를 생성하는 것은 툴 쪽에 힘을 실어도 되겠다. 

대신 나는 Struct가 많은 Component구조를 띄니까 뭔가 .. 중간지점을 하나 거쳐가는것도 나쁘지 않을것같은..

그러면 일단. 컴포넌트의 각각이 이름을 가지고 있어야 하는거 같다.

컴포넌트가 이름을 가지면 문제가 있을까. 일단 operator을 써서 대입연산은 가능하도록 만들었다. 

Struct의 내용은 최대한 건들지 않으면서 class내에 string값을 추가하자.

추가하고 왔다. 그럼 일단 Transform은 어떻게 구현을 할 것인가..? vector3에 들어가곘지 일단. 

자 일단 여기까지 많이했다 이제 커밋하고 인재원 가서 만들 것은.. 음..

JSON의 string Name..?을 변환해주어야한다. unorderedmap도 좋겠지만 컴포넌트의 개수가 많지 많으니

ENUN CLASS를 선언하고, 벡터를 사용하는것도 나빠보이지 않는다. -> InputManager처럼..! 

01.29

지금 구조에 대해 다시한번 상기를 하고 갈필요가 있다고 생각해서 글을 적어본다.
일단.. 현재 나의 생각은 모든것은 모듈안에 있고 게임엔진과 그래픽스 엔진에서 해당 정보를 바탕으로 동작을 하길 바랬다. 
하지만 그러면 종종 비효율적인 구조가 나와버린다. 

현재 머리속에 둥둥 떠다니는 문제들을 차근히 적어본다.

1. ObjectManager을 만들어야 한다.
    -> JSON으로 받아온 오브젝트 객체들을 어떻게 관리할것인지.

2.  Assimp를 그래픽스 엔진에 붙인다면.어떤 방식으로 돌아가게 할것인지 .
    Assimp가 그래픽스 엔진에 붙는다면 ...
    Assimp가 게임 엔진에 붙는다면 ...

    일단 어쉼프가 그래픽스 엔진에 붙는다면.. 음 말이 안되는데.. ?
    지금 우리 그래픽스 엔진은 그냥 renderer의 역할만 수행한다.
    그게 팀원들의 구현에 더욱 힘을 실어 줄수 있을꺼다...

    assimp를 모듈로 빼고 리소스 매니저 안에 넣었다.
    내일 리소스 매니저와 path매니저를 결합시키고 
    유경이에겐 나중에 inputmanager에서 눌린 값을 밖으로 빼는 법에 대해 생각해달라고 부탁하자.
    그래픽스는 .. 일단 구조부터.

01.30

pathManager에서 ResourceManager로 파일의 경로의 경로를 보내야한다.
아니지 그냥 리소스 매니저에서 PathManager을 하나 들고있자.
이후, PathManager에서 값을 받고 (tuple<wstring Key, wstring Path, Enum class ResourceType>으로 이루어진 이후 vector<tuple<wstring Key, wstring Path, Enum class ResourceType>>)
값을 바탕으로 Resource Type별로 저장하는 벡터를 만들고 그 안에 unordered_Map을 만든다.
-> 이부분 코드를 짜서 돌아감을 확인하고 유경이에게 부탁함. 

Entitiy
일단 Entity들은 component들을 가지고 있어야하고 Json으로 받는 string값에 따라 Entity를 추가해야한다.(이건 ObjectManager에서 해야한다.)
component들은 shared_ptr로 Entity내의 vector<IComponent>로 추가 할것이고 근데 그럼 어떤식으로 

//02.01
Json에서 받은 정보로 string으로 빌더를 만들려면.. 팩토리를 어떻게 짜야하는가..?
CreateEntity라면....일단 엔티티의 이름을 받아야한다. 

--

받았다. string값을 넣어주면 빌더로 들어가서 컴포넌트를 하나씩 붙인다. 분명 더 좋은 방법이
있겠지만 나중에 시간이 나면 고치도록 하자.
이제 ObjectManager에서 EntityFactory와 JsonManager을 가지도록 하자. 



